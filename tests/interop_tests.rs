// BSD 3-Clause License
//
// Copyright (c) 2021-2025, üçÄ‚òÄüåïüå• üåä
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//! Cross-system interoperability tests
//!
//! These tests verify that Rust container_system can exchange data with:
//! - C++ container_system
//! - Python container_system
//!
//! The tests use pre-generated wire protocol data to ensure compatibility.

use rust_container_system::prelude::*;
use std::sync::Arc;

/// Test data generated by C++ container_system
const CPP_WIRE_DATA: &str = "@header={{[3,cpp_client];[4,session1];[1,rust_server];[2,main];[5,test_message];[6,1.0.0.0];}};@data={{[count,int_value,42];[name,string_value,TestUser];[active,bool_value,true];[balance,double_value,1500.75];}};";

/// Test data generated by Python container_system (verified 100% compatible with C++)
const PYTHON_WIRE_DATA: &str = "@header={{[3,python_client];[4,worker1];[1,rust_server];[2,handler];[5,user_event];[6,1.0.0.0];}};@data={{[user_id,int_value,12345];[email,string_value,test@example.com];[verified,bool_value,true];}};";

#[test]
fn test_deserialize_cpp_data() {
    // Parse data generated by C++ system
    let container = ValueContainer::deserialize_cpp_wire(CPP_WIRE_DATA)
        .expect("Failed to deserialize C++ wire data");

    // Verify header fields
    assert_eq!(container.source_id(), "cpp_client");
    assert_eq!(container.source_sub_id(), "session1");
    assert_eq!(container.target_id(), "rust_server");
    assert_eq!(container.target_sub_id(), "main");
    assert_eq!(container.message_type(), "test_message");

    // Verify value count
    assert_eq!(container.value_count(), 4);

    // Verify int value
    let count = container.get_value("count").expect("Missing 'count' value");
    assert_eq!(count.to_int().unwrap(), 42);

    // Verify string value
    let name = container.get_value("name").expect("Missing 'name' value");
    assert_eq!(name.to_string(), "TestUser");

    // Verify bool value
    let active = container.get_value("active").expect("Missing 'active' value");
    assert_eq!(active.to_bool().unwrap(), true);

    // Verify double value
    let balance = container.get_value("balance").expect("Missing 'balance' value");
    assert!((balance.to_double().unwrap() - 1500.75).abs() < 0.001);
}

#[test]
fn test_deserialize_python_data() {
    // Parse data generated by Python system
    let container = ValueContainer::deserialize_cpp_wire(PYTHON_WIRE_DATA)
        .expect("Failed to deserialize Python wire data");

    // Verify header fields
    assert_eq!(container.source_id(), "python_client");
    assert_eq!(container.source_sub_id(), "worker1");
    assert_eq!(container.target_id(), "rust_server");
    assert_eq!(container.target_sub_id(), "handler");
    assert_eq!(container.message_type(), "user_event");

    // Verify value count
    assert_eq!(container.value_count(), 3);

    // Verify values
    let user_id = container.get_value("user_id").expect("Missing 'user_id' value");
    assert_eq!(user_id.to_int().unwrap(), 12345);

    let email = container.get_value("email").expect("Missing 'email' value");
    assert_eq!(email.to_string(), "test@example.com");

    let verified = container.get_value("verified").expect("Missing 'verified' value");
    assert_eq!(verified.to_bool().unwrap(), true);
}

#[test]
fn test_rust_to_cpp_format() {
    // Create container in Rust
    let mut container = ValueContainer::new();
    container.set_source("rust_client", "thread_1");
    container.set_target("cpp_server", "worker");
    container.set_message_type("data_sync");

    container.add_value(Arc::new(IntValue::new("sequence", 100))).unwrap();
    container.add_value(Arc::new(StringValue::new("payload", "hello_cpp"))).unwrap();
    container.add_value(Arc::new(BoolValue::new("compressed", false))).unwrap();

    // Serialize to wire format
    let wire_data = container.serialize_cpp_wire().expect("Serialization failed");

    // Verify format matches C++ expectations
    assert!(wire_data.starts_with("@header={{"));
    assert!(wire_data.contains("@data={{"));
    assert!(wire_data.contains("[3,rust_client]")); // source_id
    assert!(wire_data.contains("[4,thread_1]")); // source_sub_id
    assert!(wire_data.contains("[1,cpp_server]")); // target_id
    assert!(wire_data.contains("[2,worker]")); // target_sub_id
    assert!(wire_data.contains("[5,data_sync]")); // message_type
    assert!(wire_data.contains("[sequence,int_value,100]"));
    assert!(wire_data.contains("[payload,string_value,hello_cpp]"));
    assert!(wire_data.contains("[compressed,bool_value,false]"));

    // Verify can be deserialized back
    let restored = ValueContainer::deserialize_cpp_wire(&wire_data)
        .expect("Failed to deserialize own data");
    assert_eq!(restored.source_id(), "rust_client");
    assert_eq!(restored.value_count(), 3);
}

#[test]
fn test_rust_to_python_format() {
    // Create container in Rust for Python
    let mut container = ValueContainer::new();
    container.set_source("rust_worker", "job_42");
    container.set_target("python_analyzer", "ml_model");
    container.set_message_type("training_data");

    container.add_value(Arc::new(IntValue::new("epoch", 5))).unwrap();
    container.add_value(Arc::new(DoubleValue::new("loss", 0.0234))).unwrap();
    container.add_value(Arc::new(StringValue::new("model", "transformer"))).unwrap();

    // Serialize to wire format (compatible with Python)
    let wire_data = container.serialize_cpp_wire().expect("Serialization failed");

    // Python should be able to parse this exactly
    assert!(wire_data.contains("[epoch,int_value,5]"));
    assert!(wire_data.contains("[model,string_value,transformer]"));

    // Double value should use scientific notation compatible with Python
    assert!(wire_data.contains("loss,double_value"));

    // Roundtrip test
    let restored = ValueContainer::deserialize_cpp_wire(&wire_data).unwrap();
    assert_eq!(restored.source_id(), "rust_worker");
    assert_eq!(restored.target_id(), "python_analyzer");

    let loss = restored.get_value("loss").unwrap();
    assert!((loss.to_double().unwrap() - 0.0234).abs() < 0.0001);
}

#[test]
fn test_bytes_interop() {
    // Test binary data exchange (hex encoding)
    let mut container = ValueContainer::new();
    container.set_message_type("binary_transfer");

    let test_bytes = vec![0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE];
    container.add_value(Arc::new(BytesValue::new("signature", test_bytes.clone()))).unwrap();

    let wire_data = container.serialize_cpp_wire().unwrap();

    // Verify hex encoding (C++ uses hex, not base64)
    assert!(wire_data.contains("deadbeefcafe"));

    // Verify deserialization
    let restored = ValueContainer::deserialize_cpp_wire(&wire_data).unwrap();
    let signature = restored.get_value("signature").unwrap();
    assert_eq!(signature.to_bytes(), test_bytes);
}

#[test]
fn test_numeric_types_interop() {
    // Test core numeric types for cross-language compatibility
    // Note: Short/UShort/UInt/ULong support requires additional Value trait work
    let mut container = ValueContainer::new();
    container.set_message_type("numeric_test");

    // Test working types: Int, Long, Float, Double
    container.add_value(Arc::new(IntValue::new("i32", -123456))).unwrap();
    container.add_value(Arc::new(LLongValue::new("i64", -9876543210))).unwrap();
    container.add_value(Arc::new(FloatValue::new("f32", 3.14159))).unwrap();
    container.add_value(Arc::new(DoubleValue::new("f64", 2.71828182845))).unwrap();

    let wire_data = container.serialize_cpp_wire().unwrap();

    // Verify all types are present
    assert!(wire_data.contains("int_value"), "Missing int_value");
    assert!(wire_data.contains("llong_value"), "Missing llong_value"); // LongValue in Rust = llong in C++
    assert!(wire_data.contains("float_value"), "Missing float_value");
    assert!(wire_data.contains("double_value"), "Missing double_value");

    // Roundtrip test
    let restored = ValueContainer::deserialize_cpp_wire(&wire_data).unwrap();
    assert_eq!(restored.value_count(), 4);

    // Verify values
    assert_eq!(restored.get_value("i32").unwrap().to_int().unwrap(), -123456);
    assert_eq!(restored.get_value("i64").unwrap().to_long().unwrap(), -9876543210);
    assert!((restored.get_value("f32").unwrap().to_float().unwrap() - 3.14159).abs() < 0.0001);
    assert!((restored.get_value("f64").unwrap().to_double().unwrap() - 2.71828182845).abs() < 0.00000001);
}

// TODO: Add full numeric type support (Short, UShort, UInt, ULong, LLong, ULLong)
// Currently these types have Value trait conversion issues that need to be fixed
// in the core Value implementation before they can be properly serialized.

#[test]
fn test_empty_container_interop() {
    // Test empty container (edge case)
    let mut container = ValueContainer::new();
    container.set_source("rust", "");
    container.set_message_type("ping");

    let wire_data = container.serialize_cpp_wire().unwrap();

    // Should have header and empty data
    assert!(wire_data.contains("@header={{"));
    assert!(wire_data.contains("@data={{"));
    assert!(wire_data.ends_with("}};"));

    // Roundtrip
    let restored = ValueContainer::deserialize_cpp_wire(&wire_data).unwrap();
    assert_eq!(restored.value_count(), 0);
    assert_eq!(restored.message_type(), "ping");
}

#[test]
fn test_special_characters_in_strings() {
    // Test strings with special characters
    let mut container = ValueContainer::new();
    container.set_message_type("special_chars");

    container.add_value(Arc::new(StringValue::new("text", "Hello, World!"))).unwrap();
    container.add_value(Arc::new(StringValue::new("path", "/usr/local/bin"))).unwrap();
    container.add_value(Arc::new(StringValue::new("expr", "a=b+c"))).unwrap();

    let wire_data = container.serialize_cpp_wire().unwrap();

    // Roundtrip
    let restored = ValueContainer::deserialize_cpp_wire(&wire_data).unwrap();
    assert_eq!(restored.get_value("text").unwrap().to_string(), "Hello, World!");
    assert_eq!(restored.get_value("path").unwrap().to_string(), "/usr/local/bin");
    assert_eq!(restored.get_value("expr").unwrap().to_string(), "a=b+c");
}
